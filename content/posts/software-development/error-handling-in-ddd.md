---
title: "Error Handling in DDD"
date: "2023-11-17T14:14:01Z"
categories:
  - Software Development
tags:
  - domain driven design
  - software architecture
  - the clean architecture
---

Deciding where and how to handle errors in DDD is tricky because it involves two conflicting concerns: encapsulation of domain knowledge and user experience.

## The problem

Following DDD principles, we want to encapsulate all of our core business rules in the domain model as much as possible. At the same time, we want to provide a good user experience, which means providing helpful error messages when something goes wrong. We may also want to map some of these error messages back to particular fields in the user's request.

The problem is that the most helpful error messages are contextual, but as we push our business logic down into the domain layer, we lose sight of the user's original context. This makes it harder to generate contextual error messages, and since the domain layer doesn't have access to the user's original request, it can't map error messages back to specific fields therein.

Conversely, the application layer _does_ handle the user's request directly and therefore has full sight of the user's original context. ThereforeAs such, it can generate contextual error messages and map them back to specific fields in the user's request (if necessary).

It can be tempting therefore to lift some of the business logic from the domain layer up into the application layer. However, this leaks domain knowledge out of the domain layer and leads to code duplication because the domain layer will still want to run this logic itself anyway so that it can enforce the business rules itself.

So, how can we keep the business logic in the domain layer while having the application layer handle generating and mapping the error messages?

## Domain exceptions

One approach is to have the domain layer throw specific domain exceptions that the application layer can catch and translate into user-friendly error messages, and map them to specific fields in the user's request (if necessary). The subtype of the exception and the data contained therein fully describe the error, which allows the application layer to translate it accordingly.

These domain exceptions can also contain default error messages such that if, the application layer doesn't need to translate them into something more contextual, it can present the messages to the user as-is.

```csharp
public class BookAppointmentController
{
    public async Task<IActionResult> BookAppointment(BookAppointmentRequest request)
    {
        await _mediator.Send(request);

        return Ok();
    }
}

public class BookAppointmentHandler : IRequestHandler<BookAppointmentCommand, Guid>
{
    public async Task<Guid> BookAppointment(BookAppointmentCommand command, CancellationToken cancellationToken)
    {
        var calendar = await _repository.GetCalendarById(command.CalendarId, cancellationToken);

        if (calendar is null)
        {
            throw new NotFoundException("Calendar not found.");
        }

        Appointment appointment;

        try
        {
            appointment = calendar.BookAppointment(command.Time);
        }
        catch (ScheduleFullException e)
        {
            throw e.WithMessage("There's no availability for the time you've requested the appointment. Please try another time.");
        }

        await _repository.SaveChanges();

        return appointment.Id;
    }
}

public class Calendar
{
    public Appointment BookAppointment(DateTimeOffset time)
    {
        if (!IsActive)
        {
            throw new CalendarNotActiveException(this);
        }

        if (!HasAvailability(time))
        {
            throw new ScheduleFullException(this, time);
        }

        var appointment = Appointment.Create(this, time);
        return appointment;
    }
}
```

Advantages:

1. Cleaner overall.
1. Unlike `Result` objects, exceptions bubble up the call stack and so don't need to be handled by each layer explicitly if not necessary, for example if they don't need to be translated into more contextual error messages than the default message generated by the domain.
1. Because they bubble up, they can be logged by some global exception handler more easily.

Disadvantages:

1. Performance.

## The result pattern

An alternative approach is to have the domain layer return `Result` objects for each operation. If the operation results in an error, then the `Result` object contains a some kind of error _object_ that the application layer can translate into a user-friendly error message, and map it back to a field in the user's request (if necessary). The subtype of the error object and the data contained therein fully describe the error to the application layer, which can therefore translate it accordingly.

As with exceptions, these error objects can contain a default error message generated by the domain layer, such that if the application layer doesn't need to translate the error into something more contextual, it can present the message to the user as-is.

```csharp
public class BookAppointmentController
{
    public async Task<IActionResult> BookAppointment(BookAppointmentRequest request)
    {
        var result = await _mediator.Send(request);

        if (!result)
        {
            return result.ToApiResponse();
        }

        return Ok();
    }
}

public class BookAppointmentHandler : IRequestHandler<BookAppointmentCommand, Result<Guid>>
{
    public async Task<Result<Guid>> BookAppointment(BookAppointmentCommand command, CancellationToken cancellationToken)
    {
        var calendar = await _repository.GetCalendarById(command.CalendarId, cancellationToken);

        if (calendar is null)
        {
            return Errors.NotFound("Calendar not found.");
        }

        var appointmentResult = calendar.BookAppointment(command.Time);

        if (!appointmentResult)
        {
            if (appointmentResult.Error is AppointmentErrors.ScheduleFull)
            {
                return appointmentResult.Error.WithMessage("There's no availability for the time you've requested the appointment. Please try another time.");
            }
            else
            {
                return appointmentResult;
            }
        }

        await _repository.SaveChanges();

        var appointment = appointmentResult.Value;
        return Result.Success(appointment.Id);
    }
}

public class Calendar
{
    public Result<Appointment> BookAppointment(DateTimeOffset time)
    {
        if (!IsActive)
        {
            return AppointmentErrors.CalendarNotActive(this);
        }

        if (!HasAvailability(time))
        {
            return AppointmentErrors.ScheduleFull(this, time);
        }

        var appointment = Appointment.Create(this, time);
        return Result.Success(appointment);
    }
}
```

Advantages:

1. It doesn't come with the performance penalty that using exceptions does.

Disadvantages:

1. Unlike exceptions, `Result` objects don't bubble up the call stack and so have to be handled by each layer explicitly. _Some actually see this more explicit control-flow as a benefit._

## The can execute pattern

A similar approach to the result pattern is to ask the domain layer if it can perform an operation before trying to do so. If not, the domain layer returns an error object, as in the result pattern.

This approach works but leads to code duplication because the same business logic is run twice: once when the application layer validates the operation, and again when it executes it.

```csharp
public class BookAppointmentController
{
    public async Task<IActionResult> BookAppointment(BookAppointmentRequest request)
    {
        var result = await _mediator.Send(request);

        if (!result)
        {
            return result.ToApiResponse();
        }

        return Ok();
    }
}

public class BookAppointmentHandler : IRequestHandler<BookAppointmentCommand, Result<Guid>>
{
    public async Task<Result<Guid>> BookAppointment(BookAppointmentCommand command, CancellationToken cancellationToken)
    {
        var calendar = await _repository.GetCalendarById(command.CalendarId, cancellationToken);

        if (calendar is null)
        {
            return Errors.NotFound("Calendar not found.");
        }

        var appointmentError = calendar.CanBookAppointment(command.Time);

        if (appointmentError is not null)
        {
            if (appointmentError is AppointmentErrors.ScheduleFull)
            {
                return appointmentError.WithMessage("There's no availability for the time you've requested the appointment. Please try another time.");
            }
            else
            {
                return appointmentError;
            }
        }

        var appointment = calendar.BookAppointment(command.Time);

        await _repository.SaveChanges();

        return Result.Success(appointment.Id);
    }
}

public class Calendar
{
    public Error? CanBookAppointment(DateTimeOffset time)
    {
        if (!IsActive)
        {
            return AppointmentErrors.CalendarNotActive(this);
        }

        if (!HasAvailability(time))
        {
            return AppointmentErrors.ScheduleFull(this, time);
        }

        return null;
    }

    public Result<Appointment> BookAppointment(DateTimeOffset time)
    {
        var error = CanBookAppointment(time);

        if (error is not null)
        {
            throw new InvalidDomainOperationException(error);
        }

        var appointment = Appointment.Create(this, time);
        return Result.Success(appointment);
    }
}
```

Overall, this approach is similar to but less elegant than the result pattern, so I don't recommend using it.

## Preventing errors in the UI

One of the concerns that makes error handling in DDD challenging is user experience.

But in fact, the best user experience of all is one in which errors don't even occur: the user is blocked from performing any actions that are bound to lead to an error, either by hiding or disabling the buttons to perform them.

However, this isn't always possible. For example, the UI can't know whether or not a username has already been taken, and so has to leave this validation to the back end.

When it is possible, though, the UI requires some logic to determine if the action is valid or not. This logic is often business logic and so leads to leakage of domain knowledge into the UI.

As such, the potential improvements to the user experience should be weighed against the impacts of leaking domain knowledge and duplicating business logic into the UI.

One potential way to preserve such user experience while avoiding leaking domain knowledge is for your view models to contain abstract information that tells the UI whether or not a particular action is valid. However, this might be overkill or even impossible in some cases, and so we might decide that a small amount of domain model leakage is acceptable and worthwhile.

## Form request validation

Not all validation logic is inherently business-related. For example, validating that an email address is formatted correctly is not a core business rule; it's more related to the type of format of the data itself. Likewise for validating that a person's weight is not less than 0.

In such cases, it's better to perform this validation in the UI where we can prevent the user from submitting the form and more easily map the validation message back to the form inputs, making for a better user experience. Failing that, we can do this validation in the application layer rather than in the domain layer, where it's easier to map it back to specific fields in the user's request. This type of validation is not really the responsibility of the domain layer; the domain layer should instead focus on core business rules and therefore expect that user input passed to it has already been validated against badly-formatted and semantically-invalid data.

If the value of one of the fields in the user's request _is_ related to business rules, then the application layer can use the domain layer to perform the validation, and map any error back to that field. In the UI, we might compromise and duplicate business logic into the UI in order to perform the validation there if the compromise is worthwhile in terms of user experience.
